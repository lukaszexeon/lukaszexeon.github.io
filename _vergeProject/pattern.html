<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=no" />

  <!-- <link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css" type="text/css"> -->
  <link rel="stylesheet" href="styles.css" type="text/css">

  
  <title>The HTML5 Herald</title>
  <meta name="Embeded viever demo" content="Embeded viever demo">
  <!-- <meta name="author" content="SitePoint"> -->

  <link rel="stylesheet" href="css/styles.css?v=1.0">
  <link type="text/css" rel="sliderStylesheet" href="css/sliderStyle.css">


</head>

<body>
    <script type="module">

        import * as v3d from '../build/v3d.module.js';

        import Stats from './jsm/libs/stats.module.js';
        import { GUI } from './jsm/libs/dat.gui.module.js';
        import { OrbitControls } from "./jsm/controls/OrbitControls.js";

        var camera, scene, renderer, stats;

        var mesh;
        var amount = parseInt(window.location.search.substr(1)) || 10;
        var count = Math.pow(amount, 3);

        var raycaster = new v3d.Raycaster();
        var mouse = new v3d.Vector2(1, 1);

        var rotationMatrix = new v3d.Matrix4().makeRotationY(0.1);
        var instanceMatrix = new v3d.Matrix4();
        var matrix = new v3d.Matrix4();

        init();
        animate();

        function init() {

        camera = new v3d.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(amount, amount, amount);
        camera.lookAt(0, 0, 0);

        scene = new v3d.Scene();

        var light = new v3d.HemisphereLight(0xffffff, 0x000088);
        light.position.set(- 1, 1.5, 1);
        scene.add(light);

        var light = new v3d.HemisphereLight(0xffffff, 0x880000, 0.5);
        light.position.set(- 1, - 1.5, - 1);
        scene.add(light);

        var geometry = new v3d.SphereBufferGeometry(0.5);
        var material = new v3d.MeshPhongMaterial({ flatShading: true });

        mesh = new v3d.InstancedMesh(geometry, material, count);

        var i = 0;
        var offset = (amount - 1) / 2;

        var transform = new v3d.Object3D();

        for (var x = 0; x < amount; x ++) {

            for (var y = 0; y < amount; y ++) {

            for (var z = 0; z < amount; z ++) {

                transform.position.set(offset - x, offset - y, offset - z);
                transform.updateMatrix();

                mesh.setMatrixAt(i++, transform.matrix);

            }

            }

        }

        scene.add(mesh);

        //

        var gui = new GUI();
        gui.add(mesh, 'count', 0, count);

        renderer = new v3d.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        new OrbitControls(camera, renderer.domElement);

        stats = new Stats();
        document.body.appendChild(stats.dom);

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onMouseMove, false);

        }

        function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function onMouseMove(event) {

        event.preventDefault();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        }

        function animate() {

        requestAnimationFrame(animate);

        render();

        }

        function render() {

        raycaster.setFromCamera(mouse, camera);

        var intersection = raycaster.intersectObject(mesh);

        if (intersection.length > 0) {

            var instanceId = intersection[0].instanceId;

            mesh.getMatrixAt(instanceId, instanceMatrix);
            matrix.multiplyMatrices(instanceMatrix, rotationMatrix);

            mesh.setMatrixAt(instanceId, matrix);
            mesh.instanceMatrix.needsUpdate = true;

        }

        renderer.render(scene, camera);

        stats.update();

        }

    </script>
</body>
</html>